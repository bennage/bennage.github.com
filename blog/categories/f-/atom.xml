<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: F# | Christopher Bennage]]></title>
  <link href="http://dev.bennage.com/blog/categories/f-/atom.xml" rel="self"/>
  <link href="http://dev.bennage.com/"/>
  <updated>2013-09-07T14:14:12-07:00</updated>
  <id>http://dev.bennage.com/</id>
  <author>
    <name><![CDATA[Christopher Bennage]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is Functional Programming? Part 5, Bindings]]></title>
    <link href="http://dev.bennage.com/blog/2010/10/05/what-is-functional-programming-part-5-bindings/"/>
    <updated>2010-10-05T11:07:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2010/10/05/what-is-functional-programming-part-5-bindings</id>
    <content type="html"><![CDATA[<p><em>N.B. this is unrelated to the concept of bindings in Silverlight and WPF.</em></p>


<p>  <p>One of my aha moments in learning F# occurred while I was reading <a href="http://www.amazon.com/gp/product/1933988924?ie=UTF8&amp;tag=bluspiconinc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1933988924" target="_blank">Real World Functional Programming</a>. Specifically, it was when the meaning of the <code>let</code> keyword really clicked. Before I explain, here are couple of samples:</p>  <pre>let x = 42</p>

<p>let multiply a b = a * b</pre></p>

<p>I was predisposed to interpret <code>let</code> as merely declaring a variable. but you will recall from <a title="it all begins here" href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming/">the first post</a> that we made a distinction between working with mutable “variables” and immutable “values”. Functional languages <span title="you should also eschew obsfucation">eschew</span> mutability.</p>




<p>If you look up <code>let</code> in the <a title="let Bindings (F#)" href="http://msdn.microsoft.com/en-us/library/dd233238.aspx" target="_blank">official documentation</a> and you’ll see that it is called a <em>binding</em> and it is very clearly described:</p>




<blockquote>
  <p>A binding associates an identifier with a value or function. You use the let keyword to bind a name to a value or function.</p>
</blockquote>




<p>This also aligns with the concept of <a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science)" target="_blank">referential transparency</a> we mentioned way back in the first post. </p>




<p>This may seem obvious or even a subtle distinction to make, but I think it is fundamental in understanding the functional approach.</p>




<p><em>Update: This next part is <strong>not</strong> technically accurate and I do not mean to imply that it is. Rather, this is how my poetic eye has begun to see the code.</em></p>




<p>After this clicked with me, I also to think of</p>




<pre>let x = 42</pre>




<p>as a function with no arguments that returns a value of 42. The distinction between <em>binding to a value</em> and <em>binding to a function</em> blurs (for me). It is the <span title="With all due respect to William Blake, even though I reject the core idea of his poem.">Marriage of Value and Function</span>.</p>




<p>Next stop, pattern matching in F#.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is Functional Programming? Part 4, Linq]]></title>
    <link href="http://dev.bennage.com/blog/2010/09/22/what-is-functional-programming-part-4-linq/"/>
    <updated>2010-09-22T07:30:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2010/09/22/what-is-functional-programming-part-4-linq</id>
    <content type="html"><![CDATA[<p>If you are new to this series, <a href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming">start here</a>.</p>


<p>  <p>Before I move on to the two remaining items on my list (pattern matching and memoization), I’d like to take a brief excursion and talk about about Linq in C#. I never said it explicitly, but I have been writing this series for C# developers. I do plan to show you more F#, but while reading the aforementioned <a href="http://www.amazon.com/gp/product/1933988924?ie=UTF8&amp;tag=bluspiconinc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1933988924" target="_blank">Real World Functional Programming</a> I found it very helpful to first learn these concepts in a familiar language.</p>  <h3>Linq is Functional</h3>  <p>You might have heard it mentioned that Linq was born from the influence of functional languages. Let’s take a moment and connect some dots.</p>  <p>It <a title="regarding recursion" href="http://dev.bennage.com/blog/2010/09/14/what-is-functional-programming-part-3-recursion">the last post</a>, I gave you a functional version of our Reduce function. However, both the <a href="http://gist.github.com/575854" target="_blank">imperative version</a> and the <a href="http://gist.github.com/575857" target="_blank">functional version</a> were tied to working just with integers.</p>  <p>Now you might have notice that these specific implementations can be abstracted into the concept of <em>reducing a list of items of a certain type to a single item of the same time</em>.</p>  <p>Starting with our imperative version, we just need to replace all of the <em>int</em>s with a generic type parameter:</p>  <pre class="c#:nogutter:nocontrols" name="code">// generic imperative version
static T Reduce&lt;T&gt;(Func&lt;T, T, T&gt; reducer, IEnumerable&lt;T&gt; values)
{</p>

<pre><code>T accum = default(T);
foreach (var i in values)
{
    accum = reducer(accum, i);
}
return accum;
</code></pre>

<p>}</pre>
Well, we’d also have to initialize the <em>accum</em> variable a bit differently.</p>

<p>A generic version of the functional one is </p>




<pre class="c#:nogutter:nocontrols" name="code">static T ReduceF&lt;T&gt;(Func&lt;T, T, T&gt; reducer, IEnumerable&lt;T&gt; values, T seed)
{
    if (!values.Any()) return seed;

    var first = values.First();
    var remainder = values.Skip(1);
    var next = reducer(seed, first);

    return ReduceF(reducer, remainder, next);
}</pre>




<p>or even better</p>




<pre class="c#:nogutter:nocontrols" name="code">static T ReduceF(Func&lt;T, T, T&gt; reducer, IEnumerable&lt;T&gt; values, T seed)   
{   
    return values.Any()    
        ? ReduceF(reducer, values.Skip(1), reducer(seed, values.First()))    
        : seed;   
}  </pre>




<p>Now, in C# would could save even more typing by implementing our Reduce using Linq</p>




<pre class="c#:nogutter:nocontrols" name="code">static T ReduceLinq&lt;T&gt;(Func&lt;T, T, T&gt; reducer, IEnumerable&lt;T&gt; values)
{
    return values.Aggregate(default(T), reducer);
}</pre>




<p>Of course, after we do, we realize that our Reduce function <em>is the same as</em> the Aggregate extension method that already exists in Linq!</p>




<p>You see, if you are using Linq then you are already utilizing functional language concepts.</p>




<p><em><strong>N.B.</strong> The implementations of ReduceF are not something that you’d want to use in practice. Even though I followed a </em><a href="http://en.wikipedia.org/wiki/Tail_call" target="_blank"><em>tail call</em></a><em> style for the recursion, you’d still end up with a stack overflow in C#.</em></p>




<h4>Removing the Extra Parameter</h4>




<p>Of course, the <a href="http://gist.github.com/575857" target="_blank">functional version</a> <em>ReduceF</em> still has that extra parameter that we named <em>seed</em>. We’d like to get rid of that. </p>




<p>The approach that I have frequently seen, is to wrap the recursion function in another function that provides the initial state. In other words, we’d leave ReduceF as it is (though we’d likely make it private) and then we’d add a new function that looked like this:</p>




<pre class="c#:nogutter:nocontrols" name="code">static T ReducePublic&lt;T&gt;(Func&lt;T, T, T&gt; reducer, IEnumerable&lt;T&gt; values)
{
    return ReduceF&lt;T&gt;(reducer, values, default(T));
}</pre>




<h3></h3>




<p><em>Update: there is some good discussion about removing the extra parameter in the </em><a href="http://dev.bennage.com/blog/2010/09/14/what-is-functional-programming-part-3-recursion/"><em>comments of part 3</em></a><em>. As mentioned there, the primary reason for doing it this way is an academic desire to preserve the tail call form.</em></p>




<p>In our <a href="http://dev.bennage.com/blog/2010/10/05/what-is-functional-programming-part-5-bindings/">next post</a>, we’ll start digging a little deeper into F#.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is Functional Programming? Part 3, Recursion]]></title>
    <link href="http://dev.bennage.com/blog/2010/09/14/what-is-functional-programming-part-3-recursion/"/>
    <updated>2010-09-14T07:26:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2010/09/14/what-is-functional-programming-part-3-recursion</id>
    <content type="html"><![CDATA[<p>In the <a title="part 1 of What is Functional Programming?" href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming/">first post in this series</a>, I provided a list of concepts that I found to be characteristic of functional languages. We’ve talked bout the first four so far.</p>


<p> <ul> <li><strike>First Class Functions </strike> <li><strike>Higher Order Functions </strike> <li><strike>Pure Functions</strike>  <li><strike>Currying or Partial Application</strike> <a href="http://dev.bennage.com/blog/2010/09/09/what-is-functional-programming-part-2-currying/">Covered in the 2nd post.</a>  <li><a title="this is a joke! get it?" href="http://dev.bennage.com/blog/2010/09/14/what-is-functional-programming-part-3-recursion/">Recursion</a>  <li>Pattern Matching  <li>Memoization </li></ul> <p><em>Updated: Thanks to <a href="http://bradwilson.typepad.com/" target="_blank">Brad Wilson</a> for recommendation to use !Any() instead of Count()==0.</em></p> <h4>Recursion</h4><pre></pre></p>

<p>A recursive function is a function that calls itself. To quote Wikipedia,</p>


<blockquote>
<p>“Recursion […] is a method of defining functions in which the function being defined is applied within its own definition” <br>- <a href="http://en.wikipedia.org/wiki/Recursion" target="_blank">en.wikipedia.org/wiki/Recursion</a></p></blockquote>


<p>In general, we programmers are shy about using recursion as it can easily lead to the dreaded <a href="http://en.wikipedia.org/wiki/Stack_overflow" target="_blank">stack overflow</a>. However, recursion is crucial aspect of using functional languages. The problem of overflowing the stack can be avoided using something called <a title="tail call is not to be confused with booty call" href="http://en.wikipedia.org/wiki/Tail-call_optimization" target="_blank">tail recursion</a>. But this post is not about <a title="if you don't know how to use the interweb" href="http://lmgtfy.com/?q=what+is+recursion%3F" target="_blank">explaining what recursion is</a>, rather it is about <em>explaining its role</em> in functional languages.</p>


<p>Recursion is a mechanism for controlling flow. In fact, you’ll hardly ever see a loop when writing functional code; you’ll use recursion instead.</p>


<p>Let’s jump straight into an example. Consider our C# function <em>Reduce</em> from the first post:</p>


<pre class="c#:nogutter:nocontrols" name="code">static int Reduce(Func&lt;int, int, int&gt; reducer, IEnumerable&lt;int&gt; values)  
{  
    int accum = 0;  
    foreach (var i in values)  
    {  
        accum = reducer(accum, i);  
    }  
    return accum;  
} </pre>


<p>Now, we can define another function that produces the same output, but uses recursion instead of a loop:</p>


<pre class="c#:nogutter:nocontrols" name="code">static int ReduceF(Func&lt;int, int, int&gt; reducer, IEnumerable&lt;int&gt; values, int seed)
{
    if (!values.Any()) return seed; // #5

    var first = values.First();       // #1
    var remainder = values.Skip(1);   // #2
    var next = reducer(seed, first);  // #3

    return ReduceF(reducer, remainder, next);  //#4
}</pre>


<p>The first thing to note is that <em>ReduceF</em> includes an extra parameter, <em>seed</em>. This new parameter plays a role analogous to the variable <em>accum</em> in the original <em>Reduce</em>. In order to have the same behavior as <em>Reduce</em>, we’d need to pass in an intial value of 0 for <em>seed</em> when calling <em>ReduceF</em>. Don’t get hung up on the extra parameter though. Let’s step through the logic.</p>


<ol>
<li>Skipping over #5, we’ll come back to that. The first real step is to grab the first element in the list. We’ll use the extension method defined in System.Linq to do so. In functional terms, we’d refer to this as the <em>head</em> of the list. 
<li>Next we want to grab the remainder of the list. That is everything remaining after we’ve removed the head. The remainder is called the <em>tail</em>. Depending on the length of the list it might be any number of elements or it might be empty. Again, we’ll use a System.Linq extension method to skip over the first element and return the rest. 
<li>Here we apply our reducer function using the head of the list and the seed value. I named the value <em>next</em> because it will be the seed in our next call to <em>ReduceF</em>. 
<li>This is the recursive call. The reducer function is merely passed through. Notice though that we are passing <em>remainder</em> and <em>next</em>. Each time the function is called, the remainder has one less item. You’ll also see here how the <em>seed</em> parameter takes the place of our mutable <em>accum</em> variable from <em>Reduce</em>. 
<li>Eventually, we’ll pass in a list with no remaining items. When we detect that, we know that <em>seed</em> contains the final reduced value and so we return it. </li></ol>


<p>If the code still doesn’t make sense, spin up a quick console application and execute this</p>


<pre class="c#:nogutter:nocontrols" name="code">Func&lt;int, int, int&gt; add = (i, j) =&gt; i + j;
var integers = new[] {1, 2, 3, 4, 5};
var sum = ReduceF(add, integers, 0);</pre>


<p>and step through each call to <em>ReduceF</em>. Pay attention to the value of <em>seed</em> during each call as well as the count of elements in <em>values</em>.</p>


<h5>Recursion Helps Us Avoid Mutable Data</h5>


<p>We mentioned before that <em>Reduce</em> is a higher order function. Of course, the same is true for <em>ReduceF</em>. However, <em>ReduceF</em> is also more <em>pure</em>.</p>


<p>In our original <em>Reduce</em>, we maintained the state of our reduction using the variable <em>accum</em>. In each iteration of the loop we mutated the value of <em>accum</em>. At first glance, you might think that we are doing something similar in <em>ReduceF</em>. After all, we are defining even more variables inside of it. However, I added these superfluous variables just for readability. We can easily refactor <em>ReduceF</em> into</p>


<pre class="c#:nogutter:nocontrols" name="code">static int ReduceF(Func&lt;int, int, int&gt; reducer, IEnumerable&lt;int&gt; values, int seed)
{
    return (!values.Any()) 
        ? seed 
        : ReduceF(reducer, values.Skip(1), reducer(seed, values.First()));
}</pre>


<p>All I did here was to replace the variables with the functions that I was using to set their values. (Well, I also threw in the glorious <a title="I LOVE this guy!" href="http://msdn.microsoft.com/en-US/library/ty67wk28(v=VS.100).aspx" target="_blank">conditional operator</a> too.)</p>


<p>Now we’ve done away with any internal state! Or, well, at least there is no mutable data. Technically we are still have a state, only it is now in the form of our <em>seed </em>parameter. We’ll see why this is vitally important when we begin discussing “why should we care about functional programming”.</p>


<p><em>Check out the comment from Irné Barnard under </em><a href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming/"><em>the first post</em></a><em> to see an example of Reduce in Lisp.</em></p>


<p><a href="http://dev.bennage.com/blog/2010/09/22/what-is-functional-programming-part-4-linq/">Continue to Part 4.</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is Functional Programming? Part 2, Currying]]></title>
    <link href="http://dev.bennage.com/blog/2010/09/09/what-is-functional-programming-part-2-currying/"/>
    <updated>2010-09-09T08:00:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2010/09/09/what-is-functional-programming-part-2-currying</id>
    <content type="html"><![CDATA[<p>In <a title="part 1 of What is Functional Programming?" href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming/">my last post</a>, I provided a list of concepts that I found to be characteristic of functional languages. We’ve talked bout the first three so far.</p>


<p>  <ul>   <li><strike>First Class Functions </strike></li>    <li><strike>Higher Order Functions </strike></li>    <li><strike>Pure Functions</strike> </li>    <li>Currying or Partial Application </li>    <li>Recursion </li>    <li>Pattern Matching </li>    <li>Memoization </li> </ul>  <h4>Currying </h4>  <p><em>Updated based on some feedback from </em><a href="http://codebetter.com/blogs/Matthew.Podwysocki/" target="_blank"><em>Matthew Podwysocki</em></a><em>.</em></p>  <p>Let’s begin with the term “partial application”. This is application in the sense of “applying a function”. Based on my reading thus far, I am inferring that the term “apply” means to resolve the result of a function with a certain set of arguments. Thus, partial application is resolving the result of a function with only a <em>partial</em> set of arguments. The result will be another function that requires fewer arguments that the original function.</p>  <p><em>In light of this, currying is the act of structuring a function so that it can be partially applied.</em></p>  <p>Ok, that’s a pretty naive definition. Here’s what wikipedia says:</p>  <blockquote>   <p>“[Currying] is the technique of transforming a function that takes multiple arguments in such a way that it can be called as a chain of functions each with a single argument.” - <a href="http://en.wikipedia.org/wiki/Currying">en.wikipedia.org/wiki/Currying</a> </p> </blockquote>  <p>In the book <a href="http://www.amazon.com/gp/product/1933988924?ie=UTF8&amp;tag=bluspiconinc-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=1933988924">Real World Functional Programming: With Examples in F# and C#</a> by Tomas Petricek and Jon Skeet (a book that I found immensely helpful), the authors define currying specifically as the act of converting a function with multiple arguments into a function that takes the first argument and returns a function taking the next argument (p140). This definition clarified my reading of the wikipedia definition.</p>  <p>Let’s consider an example based on these definitions. Recall our add function (in C#) from the last post:</p>  <pre class="c#:nogutter:nocontrols" name="code">Func&lt;int, int, int&gt; add = (i, j) =&gt; i + j;</pre></p>

<p>We can convert this into:</p>




<pre class="c#:nogutter:nocontrols" name="code">Func&lt;int, Func&lt;int,int&gt;&gt; add_c = i =&gt; j =&gt; i + j;</pre>




<p>That might be hard to read, so I’ll break it down a bit. </p>




<p><em>add_c</em> is a function that takes an integer and <em>returns another function</em>. That means add_c is a higher order function. The returned function takes an integer and returns an integer.</p>




<p>If we define Tx as Func&lt;int,int&gt; then would could define <em>add_c</em> as as having the type Func&lt;int,Tx&gt;. Remember that the final parameter is the return type.</p>




<p>In regards to the nested lambda expressions that define add_c, realize that the expression <em>j =&gt; i + j</em> is the actual returned function.</p>




<p>If we were to invoke these functions to add 3 and 4, it would look like this:</p>




<pre class="c#:nogutter:nocontrols" name="code">var sum = add(3,4);
var sum = add_c(3)(4);</pre>




<p>The expression, <em>add_c(3)</em>, actually returns a function. We invoke it (or apply it) immediately providing 4 as an argument. We could <em>partially</em> apply it like this:</p>




<pre class="c#:nogutter:nocontrols" name="code">var add3 = add_c(3); // no second set of parentheses</pre>




<p>or with the type made explicit:</p>




<pre class="c#:nogutter:nocontrols" name="code">Func&lt;int,int&gt; add3 = add_c(3);</pre>




<p>So now, our curried function is <em>partially applied</em> and we can reuse this function as needed. To complete our task of adding 3 and 4 (which I guess would be fully applying the function):</p>




<pre class="c#:nogutter:nocontrols" name="code">var sum = add3(4);</pre>




<p>The type signature can get ugly quickly in C#, not to mention those crazy nested lambda expressions. Also, we could not curry our original add function without rewriting it. Even though we are able to express these functional concepts in C#, they are not elegant. </p>




<h5>Introducing A Bit of F#</h5>




<p>F# has a cleaner syntax and functions are more, um, <em>curriable</em> by default. We could express our add function in F# like this:</p>




<pre>let add (i,j) = i + j</pre>




<p>This is very much equivalent to our original C# add function. However, a more natural way in F# would be this:</p>




<pre>let add_c i j = i + j</pre>




<p>This might seems like a trivial difference, but it is not. To fully understand it, we need to look at the way F# defines the signatures of these two functions.</p>




<p>In F#, the type for <em>add</em> is</p>




<pre>int * int -&gt; int</pre>




<p>The –&gt; indicate that something is returned. Specifically, something with the type designated after the –&gt;. In this case, an integer. Now the thing to the left of the arrow is what is passed into the function. What isn’t obvious though is that <em>int * int</em> is a single thing. That is, it is a single value comprised of two integers. That’s what the * means. It’s a way of separating the constituents of a single value. This single thing is called a <a title="A tuple is a grouping of unnamed but ordered values, possibly of different types." href="http://msdn.microsoft.com/en-us/library/dd233200.aspx" target="_blank">tuple</a>. We won’t dig deep into it yet, but the important thing to understand is that <em>add</em> takes a single value (a tuple consisting of two integers) and returns an integer.</p>




<p>This signature is actually a lot like Func&lt;int,int,int&gt;. <em>(Nitpickers: Yes, we could get very exact and use the new </em><a href="http://msdn.microsoft.com/en-us/library/dd268536.aspx" target="_blank"><em>Tuple&lt;T1,T2&gt;</em></a><em> in .NET 4.0. However, it doesn’t make much of a difference practically.)</em></p>




<p>Now, let’s move on to <em>add_c.</em> The signature for it is</p>




<pre>int -&gt; int -&gt; int</pre>




<p>Look back at the wikipedia definition for currying. In particular consider “<em>a chain of functions each with a single argument</em>”.</p>




<p>Okay, now compare this to the C# definition of add_c with the nested lambdas:</p>




<pre>i =&gt; j =&gt; i + j</pre>




<p>There are oddly similar, aren’t they?</p>




<p>Now I said to interpret the –&gt; as meaning that <em>whatever comes after it is returned</em> and that <em>whatever comes before is the input</em>. If that is so, then we can understand</p>




<pre>int -&gt; int –&gt; int</pre>




<p>as meaning that the function takes a single integer and then returns a function with a signature of</p>




<pre>int –&gt; int</pre>




<p>Are you thoroughly confused? Don’t be ashamed. It takes time to sink in.</p>




<p>What this means is that our F# version of <em>add_c</em> really does have the same type that we expressed in C#. That is Func&lt;int, Func&lt;int,int&gt;&gt;. However, it’s easier on the eyes (and fingers).</p>




<p>Ultimately, this means that the natural way of writing functions in F# makes them very easy to curry. </p>




<p>Now why is this helpful? Well, we can talk about that later.</p>




<p><a title="the next in series" href="http://dev.bennage.com/blog/2010/09/14/what-is-functional-programming-part-3-recursion">Continue on to Recursion…</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is Functional Programming?]]></title>
    <link href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming/"/>
    <updated>2010-09-06T23:49:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming</id>
    <content type="html"><![CDATA[<p><em>Disclaimer: I’m still pretty green with functional programming. This is me working out my own understanding.</em></p>


<p>  <p>Wikipedia defines Functional Programming (FP) this way:</p>  <blockquote>   <p>“functional programming is a programming paradigm that treats computations as the evaluation of mathematical functions and avoids state and mutable data.” <a href="http://en.wikipedia.org/wiki/Functional_programming" target="_blank">[reference]</a></p> </blockquote>  <p>Let’s break this apart. </p>  <h4>Programming Paradigm</h4>  <p>What’s a “programming paradigm”? It’s a conceptual model for creating programs. The most popular paradigm (at least in tongue) would be <a href="http://en.wikipedia.org/wiki/Object-oriented_programming" target="_blank">Object Oriented Programming</a> (OOP). Other common paradigms are Imperative Programming (I suspect a majority of the world’s code is here) and Declarative (which includes languages like html and xaml). Here’s a list of <a title="because Wikipedia is my only reference" href="http://en.wikipedia.org/wiki/List_of_multi-paradigm_programming_languages#Paradigm_summaries" target="_blank">some other programming paradigms</a>.</p>  <p>It seems to me that most popular languages allow for the use of more than one paradigm. You’ll hear people referring to a language as “multi-paradigm”, this means it has characteristics from more than one model. For example, F# is described as having both functional and object-oriented characteristics. Some paradigms reinforce others. For example, OOP tends to be Imperative and FP tends to be Declarative. </p>  <h4>Computations</h4>  <p>In this definition, I take the term very generically. You can interpret it to mean “stuff the program does”.</p>  <h4>Evaluations of Mathematical Functions</h4>  <p>This is the core concept behind functional languages. In OOP we tend to think of functions as <em>methods that change the state of objects</em>. We have some object, say an <em>order</em>, and we call some method, like<em> submit()</em>, and the method changes the state of our object. Now, in a mathematical function we don’t really have the notion of an object or even a state. Consider a function that calculates (naively) the height of a projectile with respect to time:</p>  <blockquote>   <p>f(<em>t</em>) = -4.9<em>t</em><sup>2</sup> + 19.6<em>t</em> + 3 </p> </blockquote>  <p>With this function, we pass in a value for <em>t</em> and we get back a value representing the height. There is no “state” we are modifying in this function. There’s more to this concept, but let’s come back to it.</p>  <h4>Avoids State and Mutable Data</h4>  <p>This point follows naturally from the last one, however it was very confusing to my object-oriented mind. In fact, FP sounded a somewhat contrary to my understanding of how computers are working at a low level. Despite this, immutability is central to functional programming. In a functional language, such as F#, you don’t work with <em>variables</em>. Instead you work with <em>values</em>. Variables (as their name implies) can <a title="all is flux, nothing stays still" href="http://en.wikiquote.org/wiki/Heraclitus" target="_blank">change</a>, but values are constant. </p>  <h3>Characteristics of Functional Languages</h3>  <p>Even after breaking it apart, the definition is still a bit of an academic one. I found it beneficial to see how these concepts played out into actual features in a language. The following list is my compilation, and I’m certain it’s not exhaustive. These are common features or concepts found in many functional languages.</p>  <ul>   <li>First Class Functions </li>    <li>Higher Order Functions </li>    <li>Pure Functions </li>    <li>Currying or Partial Application </li>    <li>Recursion </li>    <li>Pattern Matching </li>    <li>Memoization </li> </ul>  <p>I’ll begin by discussing the first three items. The remaining will follow in subsequent posts.</p>  <h4>First-Class Functions </h4>  <p>This means that functions are basic types and can be passed around just like integers or strings. In C#, we have a couple of ways to do this. Here’s one example, we’ll create a function and name it “add”. It will accept two integers and returns an integer:</p>  <pre class="c#:nogutter:nocontrols" name="code">Func&lt;int, int, int&gt; add = (i, j) =&gt; i + j;</pre></p>

<p>This example relies on the type <a href="http://msdn.microsoft.com/en-us/library/bb534647.aspx" target="_blank">Func&lt;T1,T2,TResult&gt;</a> introduced in .NET 3.5 and we set the value using a <a href="http://msdn.microsoft.com/en-us/library/bb397687.aspx" target="_blank">lambda expression</a>.</p>




<p><em>Update: after writing this I found this </em><a href="http://msdn.microsoft.com/en-us/library/dd233158.aspx"><em>description of first-class functions</em></a><em> on MSDN.</em></p>




<h4>Higher Order Functions</h4>




<p>Higher order functions are functions that either take a functions as an argument or return it as a result. Let’s say that we need to write a program that takes a list of integers and then, depending on some user choice, will either add all the numbers together or subtract them. Building on our add function from above, we could create a higher order function in C# like this:</p>




<pre class="c#:nogutter:nocontrols" name="code">static int Reduce(Func&lt;int, int, int&gt; reducer, IEnumerable&lt;int&gt; values)
{
    int accum = 0;
    foreach (var i in values)
    {
        accum = reducer(accum, i);
    }
    return accum;
}</pre>




<p>I named the function “Reduce” since it reduces a list of integer down to a single integer. You can see that the first parameter matches the type of our add function from above. We can call Reduce like this:</p>




<pre class="c#:nogutter:nocontrols" name="code">var integers = new[] {1, 2, 3, 4, 5};
var sum = Reduce(add, integers);</pre>




<h4>Pure Functions</h4>




<p>A function is pure when it has <em>no side effects</em>. This mean that the function does not alter a state or mutate any data. For example, our add function is pure. We calculate a result but we do not modify any existing data. Our other function, Reduce, is pure too… well sort of. It’s pure in the sense that – if you treat it as a black box – then no state is modified. However, internally it does maintain a state. That is, the variable accum is the internal state that we modifying for each iteration of the loop. We’ll see how to remove the state from the Reduce function in another post. </p>




<p>Pure functions are closely tied to the concept of <a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science)" target="_blank">Referential Transparency</a>, which says that an expression is considered referentially transparent when it can be replace with it’s value. For example,</p>




<pre class="c#:nogutter:nocontrols" name="code">var sum = add(3,4);</pre>




<p>can be replaced with</p>




<pre class="c#:nogutter:nocontrols" name="code">var sum = 7;</pre>




<p>and there will be no change in meaning.</p>




<p><a title="curry on, I mean, carry on" href="http://dev.bennage.com/blog/2010/09/09/what-is-functional-programming-part-2-currying/">Continue on to Currying…</a></p>

]]></content>
  </entry>
  
</feed>
