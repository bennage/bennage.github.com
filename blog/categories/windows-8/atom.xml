<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Windows 8 | Christopher Bennage]]></title>
  <link href="http://dev.bennage.com/blog/categories/windows-8/atom.xml" rel="self"/>
  <link href="http://dev.bennage.com/"/>
  <updated>2013-09-07T14:14:12-07:00</updated>
  <id>http://dev.bennage.com/</id>
  <author>
    <name><![CDATA[Christopher Bennage]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[WinJS: Unpacking Promises]]></title>
    <link href="http://dev.bennage.com/blog/2012/08/21/winjs-unpacking-promises/"/>
    <updated>2012-08-21T12:02:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2012/08/21/winjs-unpacking-promises</id>
    <content type="html"><![CDATA[<p>N.B. <em>If you don't know anything about WinJS, take a moment to peruse <a href="http://dev.bennage.com/blog/2012/08/01/a-brief-introduction-to-winjs/">this primer</a>. Also, the context of this post is the <a href="http://hilojs.codeplex.com/">p&amp;p Hilo project</a>.</em></p>

<p><em>In particular, you should read about promises and <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh700330.aspx">asynchronous programming in JavaScript</a>. Derick Bailey also wrote <a href="http://lostechies.com/derickbailey/2012/07/19/want-to-build-win8winjs-apps-you-need-to-understand-promises/">about promises</a> on his blog.</em></p>

<h2>A Bit About Promises</h2>

<p>A promise is an object. It is not a function and it is not the <em>value</em> returned from the async operation. To get to the value, you need to call the <code>then</code> method on the promise object. You pass a callback function as an argument to <code>then</code>. The promise invokes the callback and passes the value you're interested in into the callback. Clear as mud, right?</p>

<p>Here's a fictitious example that pretends like calculating a random number requires an async operation:</p>

<pre><code>getRandomNumberAsync().then(function(someNumber) { 
    // do stuff with `someNumber`
});
</code></pre>

<p>The call to <code>then</code> returns a promise itself. You could do this:</p>

<pre><code>getRandomNumberAsync().then(function(someNumber) { 
    // do stuff with `someNumber`
}).then(function() {
    // more stuff
});
</code></pre>

<p>Or written another way:</p>

<pre><code>var afterRandomNumber = getRandomNumberAsync().then(function(someNumber) { 
    // do stuff with `someNumber`
});

afterRandomNumber.then(function() {
    // more stuff
});
</code></pre>

<p>The two example above are the <em>same</em>.</p>

<p>Now if our callback function returns a value, that value is passed along to the next promise's callback.</p>

<pre><code>getRandomNumberAsync().then(function(someNumber) { 
    return someNumber + 1;
}).then(function(someNumberPlusOne) {

});
</code></pre>

<p>This allows you to easily chain promises, piping the output of one into the next callback in the chain.</p>

<pre><code>getRandomNumberAsync().then(function(someNumber) { 
    return someNumber + 1;
}).then(function(someNumberPlusOne) {
    return someNumberPlusOne + 1;
}).then(function(someNumberPlusTwo) {

});
</code></pre>

<p>Of course, this is a bit silly when then operations are not async. It's more interesting when the thing you return from the callback is also a promise. Let's make a another fictitious async function, this time one that needs input:</p>

<pre><code>getRandomNumberHigherThanAsync(10).then(function(someNumberOverTen){
    // do something with `someNumberOverTen`
});
</code></pre>

<p>Now we can do this:</p>

<pre><code>getRandomNumberAsync().then(function(someNumber) { 
    return getRandomNumberHigherThanAsync(someNumber);
}).then(function(something){
    // What will `something` be?
});
</code></pre>

<p>In the example above, you might think that <code>something</code> will be the promise returned from <code>getRandomNumberHigherThanAsync</code>. It's not. Instead, it's the <em>value</em> that <code>getRandomNumberHigherThanAsync</code> produces and would pass into its callback. <em>Returning another promise from within the callback for a promise is a special case.</em> Though it's probably the most frequent case.</p>

<h2>Putting Promises Together</h2>

<p>Now let's pretend we have a set of functions that all return promises, named <code>A</code> through <code>E</code>. If we wanted to execute them in sequence, passing the results from one to the next, we <em>could</em> write it this:</p>

<pre><code>A().then(function(a) {
    return B(a).then(function(b){
        return C(b).then(function(c){
            return D(c).then(function(d){
                return E(d);
            });
        });
    });
});
</code></pre>

<p>Yeah, that hurts my eyes too. Though I found that I was writing my code <em>just like this</em> at first.</p>

<p>However, we should realize that <code>A.then()</code> returns a promise and that that promise completes only when all of the nested promises have completed. If we wanted to execute a new function <code>F</code> after all these steps, we could do it like this:</p>

<pre><code>var waitForAllToBeDone = A().then(function(a) {
    return B(a).then(function(b){
        return C(b).then(function(c){
            return D(c).then(function(d){
                return E(d);
            });
        });
    });
});

waitForAllToBeDone().then(function(e){
    return F(e);
});
</code></pre>

<p>However, that last inline callback has the same signature as <code>F</code>. That means that we can simplify to this:</p>

<pre><code>waitForAllToBeDone().then(F);
</code></pre>

<p>Now we realize that what we did for <code>F</code> is also true for <code>E</code>. In fact, it is true for the entire chain. We can simplify that nasty nested beast to:</p>

<pre><code>A().then(B).then(C).then(D).then(E).then(F);
</code></pre>

<p>Much nicer.</p>

<h2>A Real Example</h2>

<p>Let's bring this home. While working on <a href="http://hilojs.codeplex.com/">HiloJS</a> we needed to copy an image thumbnail to a new file. It sounds simple, but it requires the following steps:</p>

<ol>
<li>Open a file that we will write <em>to</em>. We'll call this the <strong>target</strong> file.</li>
<li>Get the thumbnail image from another file. We'll call this the <strong>source</strong> file. (WinRT creates the thumbnail for us from the source.)</li>
<li>Copy the stream from the thumbnail source to the target file's input stream.</li>
<li>Flush the output stream.</li>
<li>Close both the input and the output stream.</li>
</ol>


<p>(Actually we don't really care about the order of the first two steps. They could be switched.)</p>

<p>Our initial implementation looked liked this:</p>

<pre><code>function writeThumbnailToFile(sourceFile, targetFile) {

    var whenFileIsOpen = targetFile.openAsync(fileAccessMode.readWrite);

    return whenFileIsOpen.then(function (outputStream) {

        return sourceFile.getThumbnailAsync(thumbnailMode.singleItem)).then(function (thumbnail) {
            var inputStream = thumbnail.getInputStreamAt(0);
            return randomAccessStream.copyAsync(inputStream, outputStream).then(function () {
                return outputStream.flushAsync().then(function () {
                    inputStream.close();
                    outputStream.close();
                });
            });
        });
    });
}
</code></pre>

<p>Then we had a code review with the always helpful Chris Tavares. He pointed us in a more excellent direction. We were able to change the code to this:</p>

<pre><code>function writeThumbnailToFile(sourceFile, targetFile) {

    var whenFileIsOpen = targetFile.openAsync(fileAccessMode.readWrite);
    var whenThumbailIsReady = sourceFile.getThumbnailAsync(thumbnailMode.singleItem);

    var whenEverythingIsReady = WinJS.Promise.join([whenFileIsOpen, whenThumbailIsReady]);

    var inputStream, outputStream;

    whenEverythingIsReady.then(function (args) {
        outputStream = args[0];
        var thumbnail = args[1];
        inputStream = thumbnail.getInputStreamAt(0);
        return randomAccessStream.copyAsync(inputStream, outputStream);

    }).then(function () {
        return outputStream.flushAsync();

    }).then(function () {
        inputStream.close();
        outputStream.close();
    });
}
</code></pre>

<p>A couple of notable differences:</p>

<ol>
<li><p>In the first implementation, we passed along some values via the closure (e.g., <code>inputStream</code> and <code>outputStream</code>). In the second, we had to declare them in the outer scope because there was no common closure.</p></li>
<li><p>In the first implementation, we chained <code>targetFile.openAsync</code> and <code>sourceFile.getThumbnailAsync</code>, but we didn't really need to. We made the real relationship more explicit in the second using <code>WinJS.Promise.join</code>. That mean the values of these two promises came to us in an arrays (we named it <code>args</code>).</p></li>
</ol>


<h2>Summary</h2>

<p>Understanding how promises can be composed really helped us to make the code more readable. It can be difficult to wrap your head around the way they work, but (like it or not) promises are an essential part of writing apps with WinJS.</p>

<h2>Fictitious Functions Implementations</h2>

<pre><code>// an example implementation of getRandomNumberAsync

function getRandomNumberAsync() {
    return WinJS.Promise.as(Math.random());
}

// an example implementation of getRandomNumberHigherThanAsync

function getRandomNumberHigherThanAsync(minimum) {
    var someNumber = Math.random() + minimum;
    return WinJS.Promise.as(someNumber);
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unit Testing WinJS: First Steps]]></title>
    <link href="http://dev.bennage.com/blog/2012/08/15/unit-testing-winjs/"/>
    <updated>2012-08-15T16:25:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2012/08/15/unit-testing-winjs</id>
    <content type="html"><![CDATA[<p>N.B. <em>If you don't know anything about WinJS, take a moment to peruse <a href="http://dev.bennage.com/blog/2012/08/01/a-brief-introduction-to-winjs/">this primer</a>. Also, the context of this post is the <a href="http://hilojs.codeplex.com/">p&amp;p Hilo project</a>.</em></p>

<p>One of the first questions we've been struggling with is how to best test a WinJS app.  (I'm going to use the term "unit test" somewhat loosely. Some of our tests would technically be classified as "integration tests".)</p>

<h2>Where to run the tests</h2>

<p>Our first barrier to unit testing a WinJS app was finding a convenient way to run the tests.
The primary difficulty is that the WinRT APIs are only available in the context of a Windows 8 app (and that's also practicially the case for WinJS as well). So if your tests need to touch either one, the only choice you currently have is to run the tests inside a Windows 8 app.</p>

<p><img class="right" src="/images/posts/winjs-test-solution.png"></p>

<p>After some experimentation, we choose to include a second app in our solution to host the unit tests. (At one point, we had the tests embedded in the actual app itself; executing them with a hidden keyboard shortcut.) Having two apps means that we have to share the source that's under test. Currently, we're just <a href="http://msdn.microsoft.com/en-us/library/9f4t9t92.aspx">manually linking the files</a>. I also have to manually go into the default.html and add references to the scripts. Ultimately, I'd like to have this automated, but that's a task for another day.</p>

<p><em>Notice in the screen shot of the solution explorer, that the <code>Hilo</code> folder in the <code>Hilo.Specifications</code> project has a little red <strong>x</strong>. This is because the folder doesn't physically exist there. Instead, there are just links to the corresponding files in the main <code>Hilo</code> project.</em></p>

<h2>How to run the tests</h2>

<p>We settled on <a href="http://visionmedia.github.com/mocha/">Mocha</a> for running our unit tests. Mocha is popular in the <a href="http://nodejs.org/">Node.js</a> and it has (in my opinion) one of the better async test stories. This is really important when building Windows 8 apps because (much like Node.js) all the APIs are asynchronous.</p>

<p>We also choose to use a <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD-style</a> for the tests. However, Mocha supports several styles, including a QUnit style.</p>

<p>Mocha will pass a function into your tests for you to call once the asynchronous work is complete. For example:</p>

<pre><code>it('test something asynchronous using a promise', function(done) {

    doSomeWork().then(function(result){

        if(!result) { // or whatever assertion is appropriate
            throw new Error('test failed') 
        } else {
            done(); // we call the function after the async work is complete
        }

    });
});
</code></pre>

<p>If you don't understand the call to <code>then</code>, take a moment to read about <a href="http://msdn.microsoft.com/en-us/library/windows/apps/hh700330.aspx">async programming in WinJS apps</a>.</p>

<p>What's great about Mocha is that if you omit the <code>done</code> parameter, then the harness automagically assumes the test is synchronous. Very nice.</p>

<p>We did have <a href="https://github.com/visionmedia/mocha/issues/502">one problem</a> with Mocha. It has an internal recursive process that can cause a stack overflow in IE. <a href="http://lostechies.com/derickbailey/">Derick Bailey</a> came up with a quick workaround by resetting the stack before each test with a call to <code>setTimeout</code> in our <a href="http://hilojs.codeplex.com/SourceControl/changeset/view/13593c579fb6#Hilo.Specifications%2fspec.helpers.js">test helper script</a>.</p>

<pre><code>beforeEach(function (done) {
    setTimeout(done, 0);
});
</code></pre>

<p>As mentioned before, Mocha is primarly for Node. However Mocha's creator <a href="http://tjholowaychuk.com/">TJ Holowaychuk</a>, graciously allowed me to setup a <a href="http://nuget.org/packages/mochajs-browseronly">Nuget package</a> to make it easier for Windows developers to use Mocha.</p>

<h3>Steps to install Mocha</h3>

<ol>
<li>Right-click on the test project and select Manage Nuget Packages</li>
<li>Seach for "mocha"</li>
<li>Select "mocha for browsers" and click Install</li>
<li>Open the default.html page and reference the scripts. They are located in the \lib folder. (see below)</li>
<li>Open the default.js file and add <code>mocha.run()</code> some where after app is ready.</li>
</ol>


<p>In my <a href="http://hilojs.codeplex.com/SourceControl/changeset/view/13593c579fb6#Hilo.Specifications%2fdefault.html">default.html</a>:</p>

<pre><code>&lt;link rel="stylesheet" type="text/css" href="http://dev.bennage.com/lib/mocha.css"&gt;
&lt;script src="http://dev.bennage.com/lib/mocha.js"&gt;&lt;/script&gt;
 &lt;!-- choose the style that you want for tests first --&gt;
&lt;script&gt;mocha.setup('bdd')&lt;/script&gt;

&lt;!-- then reference your actual test script --&gt;
</code></pre>

<p>A simplified <a href="http://hilojs.codeplex.com/SourceControl/changeset/view/13593c579fb6#Hilo.Specifications%2fdefault.js">default.js</a> might be:</p>

<pre><code>ï»¿(function () {
    'use strict';

    var activation = Windows.ApplicationModel.Activation,
        app = WinJS.Application,
        nav = WinJS.Navigation;

    app.addEventListener('activated', function (args) {
        if (args.detail.kind === activation.ActivationKind.launch) {
            args.setPromise(WinJS.UI.processAll().then(function () {
                mocha.run();
            }));
        }
    }, false);

    app.start();
})(this);
</code></pre>

<h2>What to mock?</h2>

<p>The next big question was about making our code "testable". I don't like saying that because, in general, we don't want test concerns to be bleed into the code. (I have some <a href="http://dev.bennage.com/blog/2008/03/30/the-roots-of-best-practices/">personal principles</a> about these sorts of practices.)</p>

<p>At first, I tried to create a system that would completely mock out every WinRT API. I modeled it after <a href="http://www.commonjs.org/specs/modules/1.0/">CommonJS Modules</a>. In essence, I made every "module" in my app use a <code>require</code> function to locate its dependencies. Using this approach you had to reference the WinRT API in the very unnatural form of:</p>

<pre><code>var knownFolders = require('Windows.Storage.KnownFolders'); 
</code></pre>

<p>instead of the standard:</p>

<pre><code>var knownFolders = Windows.Storage.KnownFolders;
</code></pre>

<p>This made it easy (ish) to mock out the WinRT call in my tests. However, there were a <a href="http://hilojs.codeplex.com/discussions/364538">number</a> of <a href="http://hilojs.codeplex.com/discussions/366305">negatives</a> to this approach. Mostly, it added an extra layers of complexity and it broke tooling (such as Intellisense and code navigation).</p>

<p>Instead, we decided to take a more <a href="http://dev.bennage.com/blog/2010/09/06/what-is-functional-programming/">functional</a> approach to our code. As much as was reasonable, we tried to write our code as <em>functions with inputs</em> instead of as <em>objects with dependencies</em>. Then in our tests we could invoke the functions passing in "mocks" that were shaped like the necessary WinRT dependencies. This mean that we had thin layers in our app that invoked the functions and passed in the necessary bits. It also meant that in a few cases, we had to run tests against the actual WinRT objects. (Technically, I would call these "integration" tests instead of "unit" tests).</p>

<p>The best example of this approach in the HiloJS project (so far) can be found in <a href="http://hilojs.codeplex.com/SourceControl/changeset/view/13593c579fb6#Hilo%2fHilo%2fTiles%2ftileUpdater.js">tileUdater.js</a>. In that file, we create a simple object that coordinates the real work using a set of functions. The major functions are defined in their own files (all inside the \Hilo\Tiles folder). We "export" these functions using <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br212667.aspx"><code>WinJS.Namespace.define</code></a>. Exporting them makes them available to the code in tileUpdater.js as well as our tests.</p>

<h2>Summary</h2>

<p>So far this arrangement has worked really well for us. Working with Mocha has been a lot of fun. The test authoring experience isn't quite as smooth as I'd like, but I'm sure that will come as we gain more experience.
Remember though, this project is very much a journey, so keep on eye on the <a href="http://hilojs.codeplex.com/">project site</a>. We'll be writing more about it as we learn.</p>

<p>As always, your feedback is greatly desired. Do you have a better way? How does this approach strike? Feel free to speak up our the <a href="http://hilojs.codeplex.com/discussions">project's discussion board</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A Brief Introduction to WinJS]]></title>
    <link href="http://dev.bennage.com/blog/2012/08/01/a-brief-introduction-to-winjs/"/>
    <updated>2012-08-01T16:42:00-07:00</updated>
    <id>http://dev.bennage.com/blog/2012/08/01/a-brief-introduction-to-winjs</id>
    <content type="html"><![CDATA[<p>I'm a few weeks into my <a href="http://hilojs.codeplex.com/">latest p&amp;p project</a>. We're exploring how to build Windows 8 applications with HTML and JavaScript. I'll refer to these apps as "WinJS apps".</p>

<p>This post is a very brief overview and introduction to some terminology related to WinJS. It's my personal take and it's certainly not official. All of the official documentation can be found at the <a href="http://msdn.microsoft.com/windows/apps/">Dev Center</a>.</p>

<h2>What is a WinJS app?</h2>

<p>In my recent expereince there is often some confusion about Windows 8 apps in general, so let's begin there.</p>

<p>Windows 8 apps are similar to what you would find on Windows Phone, iOS, or Android, in that they are sandboxed and they have to declare to user when they use more <em>advanced</em> APIs (like location awareness for example). The only way for users to get Windows 8 apps is through the <a href="http://msdn.microsoft.com/library/windows/apps/br230836">store</a>.</p>

<p>Windows 8 apps can be built with C++ and XAML, C#/VB.NET and XAML, and JavaScript and HTML. All three choices have access to the <a href="http://msdn.microsoft.com/en-US/library/windows/apps/br211377">Windows Runtime</a>. It's the consolidated API was interacting with the OS.</p>

<p>When using JavaScript, the Windows Runtime is available as the global object <code>Windows</code>.</p>

<p>In addition to the Windows Runtime (which I sometimes personally call WinRT), there is the <em>Windows Library for JavaScript</em> or <em>WinJS</em>. This is different from WinRT. It's pure JavaScript and only availabe to JavaScript apps. It's automatically referenced when you create a new project. It is available as the global object <code>WinJS</code>.</p>

<p>WinJS includes lots of helpful bits:</p>

<ul>
<li>an implementation of <a href="http://wiki.commonjs.org/wiki/Promises/A">CommonJS Promises/A</a>.</li>
<li>some advanced UI controls</li>
<li>DOM utilities</li>
<li>navigation and xhr helpers</li>
<li>and more</li>
</ul>


<p>Technically, you don't <em>have</em> to use WinJS. If you wanted to, you could ignore it. In practice though, it can be pretty useful.</p>

<p>Finally, you can develop with standards-based HTML, CSS, and JavaScript without worrying about cross-browser issues. For example, I haven't felt the need for jQuery because I can just use <a href="http://www.w3.org/TR/selectors-api/"><code>document.querySelector</code></a> without fear.</p>

<p>Likewise, don't go looking through WinJS for standard controls; just use the native HTML controls that you already know and love.</p>
]]></content>
  </entry>
  
</feed>
